#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define SIZE_MEM 16384 // Tama�o m�ximo para el arreglo M
#define FILAS_SEG 5      // N�mero de filas para el arreglo S
#define COLUMNAS_SEG 2       // N�mero de columnas para el arreglo S
#define CANT_REG 16

void imprimir_en_binario(int c) {
    printf("%6hhu en binario es: ", c);
    for (int i = 15; i >= 0; i--) {
        // Verificar si el bit en la posición i está encendido (1) o apagado (0)
        if (c & (1 << i)) {
            printf("1");
        } else {
            printf("0");
        }
    }
    printf("\n");
}

// Funci�n para revertir el orden de los bytes
unsigned short int reverseBytes(unsigned short int num) {
    return (num >> 8) | (num << 8);
}

int swap_endianness(int value) {
    return ((value >> 24) & 0xFF) | ((value << 8) & 0xFF0000) |
           ((value >> 8) & 0xFF00) | ((value << 24) & 0xFF000000);
}

// Definicion del struct MV
typedef struct {
    char M[SIZE_MEM];
    int R[CANT_REG];
    short int S[FILAS_SEG][COLUMNAS_SEG];
} TMV;

void MOV(char op1, int v1, char op2, int v2, TMV *MV);
void ADD(char op1, int v1, char op2, int v2, TMV *MV);
void SUB(char op1, int v1, char op2, int v2, TMV *MV);
void MUL(char op1, int v1, char op2, int v2, TMV *MV);
void DIV(char op1, int v1, char op2, int v2, TMV *MV);
void SWAP(char op1, int v1, char op2, int v2, TMV *MV);
void CMP(char op1, int v1, char op2, int v2, TMV *MV);
void AND(char op1, int v1, char op2, int v2, TMV *MV);
void OR(char op1, int v1, char op2, int v2, TMV *MV);
void XOR(char op1, int v1, char op2, int v2, TMV *MV);
void SHL(char op1, int v1, char op2, int v2, TMV *MV);
void SHR(char op1, int v1, char op2, int v2, TMV *MV);
void RND(char op1, int v1, char op2, int v2, TMV *MV);
void writeSYS(char AL, TMV *MV, int posMemoria);
void readSYS(char AL, TMV *MV, int posMemoria);
void SYS(char op2, int v2, TMV *MV);
void JMP(char op2, int v2, TMV *MV);
void JMP(char op2, int v2, TMV *MV);
void JZ(char op2, int v2, TMV *MV);
void JP(char op2, int v2, TMV *MV);
void JN(char op2, int v2, TMV *MV);
void JNZ(char op2, int v2, TMV *MV);
void JNP(char op2, int v2, TMV *MV);
void JNN(char op2, int v2, TMV *MV);
void LDH(char op2, int v2, TMV *MV);
void LDL(char op2, int v2, TMV *MV);
void NOT(char op2, int v2, TMV *MV);
void PUSH(char op2, int v2, TMV*MV);
void POP(char op2, int v2, TMV*MV);
void CALL(char op2, int v2, TMV*MV);
void RET(TMV *MV);
void STOP(TMV *MV);

//Funcion que leer la instruccion y el tipo de operando y los devuelve
void ReadAux(char byte, char *instr, char *op1, char *op2) {
    char mask1=0b00011111;
    char mask2=0b00000011;
    char aux;
    *instr=byte&mask1;
    byte=byte>>4;
    *op1=byte&mask2;
    byte=byte>>2;
    *op2=byte&mask2;
}

//Funcion que de acuerdo al tipo de operando que le llega, devuelve que de que tamanio es
void SetSizes(char op1, char op2, char *size1, char *size2);

//Funcion que de acuerdo al tamanio que le llega devuelve el valor de la posicion indicada
void ReadSegunSize(char size, int *v, TMV *MV, int Dissasembler_True, int *cuantos);

//Funcion que recibe los 2 operando
void ReadOp(char op1, char op2, FILE *arch, TMV *MV, int *v1, int *v2, int Dissasembler_True){
    int cuantos, i;
    char size1, size2;
    cuantos=0;
    SetSizes(op1, op2, &size1, &size2);
    //Lee primero el OPERANDO 2 y despues el OPERANDO 1
    //printf("en la memoria tengo %x %x %x %x  \n",(unsigned char)MV->M[MV->R[5]], (unsigned char)MV->M[MV->R[5]+1], (unsigned char)MV->M[MV->R[5]+2], (unsigned char)MV->M[MV->R[5]+3]);
    ReadSegunSize(size2, &(*v2), MV, Dissasembler_True, &cuantos);
    ReadSegunSize(size1, &(*v1), MV, Dissasembler_True, &cuantos);
    //printf("en readop v1 es %x  v2 es %x  \n",*v1, *v2);
    if (Dissasembler_True){
        for (i=0; i<12-cuantos; i++){
            printf("  ");
        }
        printf(" | ");
    }
}

//Ejemplo a opera llega la instruccion (0), op1 (2), op2 (1), v1 (f), v2 (0)
void Opera(char instr, char op1, char op2, int v1, int v2, TMV *MV, char bufferversion){
  //  MV->M[80]=0x12;
    switch(instr) {
    case 0://MOV
        MOV(op1, v1, op2, v2, MV);
        break;
    case 1://ADD
        ADD(op1, v1, op2, v2, MV);
        break;
    case 2://SUB
        SUB(op1, v1, op2, v2, MV);
        break;
    case 3://SWAP
        SWAP(op1, v1, op2, v2,MV);
        break;
    case 4://MUL
        MUL(op1, v1, op2, v2, MV);
        break;
    case 5://DIV
        DIV(op1, v1, op2, v2, MV);
        break;
    case 6://CMP
        CMP(op1, v1, op2, v2, MV);
        break;
    case 7://SHL
        SHL(op1, v1, op2, v2, MV);
        break;
    case 8://SHR
        SHR(op1, v1, op2, v2, MV);
        break;
    case 9://AND
        AND(op1, v1, op2, v2, MV);
        break;
    case 10://OR
        OR(op1, v1, op2, v2, MV);
        break;
    case 11://XOR
        XOR(op1,v1,op2,v2,MV);
        break;
    case 12://RND
        RND(op1,v1,op2,v2,MV);
        break;
    case 16://SYS
        SYS(op2, v2, MV);
        //printf("SALGO DE OPERA \n");
        break;
    case 17://JMP
        JMP(op2, v2, MV);
        break;
    case 18://JZ
        JZ(op2, v2, MV);
        break;
    case 19://JP
        JP(op2, v2, MV);
        break;
    case 20://JN
        JN(op2, v2, MV);
        break;
    case 21://JNZ
        JNZ(op2, v2, MV);
        break;
    case 22://JNP
        JNP(op2, v2, MV);
        break;
    case 23://JNN
        JNN(op2, v2, MV);
        break;
    case 24://LDL
        LDL(op2, v2, MV);
        break;
    case 25://LDH
        LDH(op2, v2, MV);
        break;
    case 26://NOT
        NOT(op2, v2, MV);
        break;
    case 27://PUSH
        if (bufferversion==1){
            printf("ERROR INSTRUCCION INVALIDA");
            exit(1);
        }
        else
        PUSH(op2, v2, MV);
        break;
    case 28://POP
        if (bufferversion==1){
            printf("ERROR INSTRUCCION INVALIDA");
            exit(1);
        }
        else
        POP(op2, v2, MV);
        break;
    case 29://CALL
        if (bufferversion==1){
            printf("ERROR INSTRUCCION INVALIDA");
            exit(1);
        }
        else
        CALL(op2, v2, MV);
        break;
    case 30://RET
        if (bufferversion==1){
            printf("ERROR INSTRUCCION INVALIDA");
            exit(1);
        }
        else
        RET(MV);
        break;
    case 31://STOP
        STOP(MV);
        }
  }

int getOp(TMV *MV, char op, int v){
    int reg, offset, sec, i, x, vaux, tamcel;
    short int index;
    unsigned int aux;

    switch(op){
        case 0:   //operador de memoria
            tamcel=(v>>22);
            reg=(v>>16)&0xF;
            offset=v&0xFFFF;
            //printf("el registro es %x  \n",reg);
            //printf("el offset es %x  \n",offset);
            switch(tamcel){
            case 0:
                //printf("entre al case 0 \n");
                index=MV->S[MV->R[reg]>>16][0]+(MV->R[reg]&0xFFFF)+offset;
                for(int i = index; i < index+4; ++i) {
                    aux = (aux << 8) | (MV->M[i] & 0xFF);
                }
                break;
            case 2:
            //printf("entre al case 2 \n");
                index=MV->S[MV->R[reg]>>16][0]+(MV->R[reg]&0xFFFF)+offset;
                for(int i = index; i < index+2; ++i) {
                    aux = (aux << 8) | (MV->M[i] & 0xFF);
                }
                if (aux & 0x8000)  // Si el bit más significativo (bit 15) está activado
                aux|= 0xFFFF0000;
                break;
            case 3:
            //printf("entre al case 3 \n");
                index=MV->S[MV->R[reg]>>16][0]+(MV->R[reg]&0xFFFF)+offset;
                //printf("index es %d", index);
                aux =(MV->M[index] & 0xFF);
                if (aux & 0x80)  // Si el bit más significativo (bit 15) está activado
                aux|= 0xFFFFFF00;
                //printf("AUX EN GETOP ES %x \n", aux);
                break;
            }
            return  aux;
            break;
        case 1: //operador inmediato
           // printf("v es %x \n",v);
            if (v & 0x8000)  // Si el bit más significativo (bit 15) está activado
            v|= 0xFFFF0000; // Extiende el signo llenando los bits más altos con 1s
            return v;
            break;
        case 2: //operador de registro
            reg=v&0xF;
            sec=(v>>4)&0b11;
           // printf("reg es %x\n",reg);
           // printf("sec es %x\n",sec);
            switch(sec){
                case 0:
                    return MV->R[reg];
                    break;
                case 1:
                    vaux=MV->R[reg]&0xFF;
                    if (vaux & 0x80)
                    vaux|= 0xFFFFFF00;
                    return vaux;
                    break;
                case 2:
                    vaux=(MV->R[reg]>>8)&0xFF;
                    if (vaux & 0x80)
                    vaux|= 0xFFFFFF00;
                    return vaux;
                    break;
                case 3:
                    vaux = MV->R[reg]&0xFFFF;
                    if (vaux & 0x8000)
                     vaux|= 0xFFFF0000;
                     return vaux;
                    break;
            }
            break;
        case 3: //nada
            break;
    }
}

void setOp(TMV *MV, char op, int v, int op2){
    int mask=0xFF;
    //printf("v es %06x \n", v);
    int reg, i=0;
    int x;
    char sec;
    int offset, tamcel;
    short int index;
    unsigned int *int_ptr;
    int mask3erbyte= ~(0xFF << 8);
    int mask4tobyte= 0xFFFFFF00;
    int mask2bytes = 0xFFFF0000;
    int op2Corrido, op2Backup;


    switch(op){
        case 0: //operador de memoria
            tamcel=(v>>22);
            reg=(v>>16)&0xF;
            offset=v&0xFFFF;
           // printf("op2 es %x", op2);
            op2=swap_endianness(op2);
            //printf("op2 es %x", op2);
            index=MV->S[MV->R[reg]>>16][0]+(MV->R[reg]&0xFFFF)+offset;

            if (index < 0){
                printf("Error: Segmentation Fault.\n");
                exit(EXIT_FAILURE);
            }
          //  if (MV->R[4] > 0 && index < MV->S[1][1]){
                //printf("Error: Segmentation Fault.\n");
               // exit(EXIT_FAILURE);
          //  }
          // if (MV->R[4] <= 0 && index < MV->S[0][1]){
                //printf("Error: Segmentation Fault.\n");
                //exit(EXIT_FAILURE);
           // }
            switch(tamcel){
            case 0:
                 int_ptr = (int *)&(MV->M[index]);
                 *int_ptr= op2;
                break;
            case 2:
                op2=swap_endianness(op2);
                int_ptr = (int *)&(MV->M[index]);
                op2=op2&0x0000FFFF;
                *int_ptr= op2;
                break;
            case 3:
                op2=swap_endianness(op2);
                int_ptr = (int *)&(MV->M[index]);   
                op2=op2&0x000000FF;
                *int_ptr=(char)op2;
                break;
            }



           
           // printf("el valor de la celda apuntada por intptr es %08x \n",*int_ptr);
           // printf("en la memoria desde index hay %02x %02x %02x %02x \n",MV->M[index], MV->M[index+1],MV->M[index+2],MV->M[index+3]);
           break;
        case 1: //operador inmediato
            break;
        case 2: //operador de registro
            reg=v&0xF;
            sec=(v>>4)&0b11;
            //printf("reg es %x\n",reg);
            //printf("sec es %x\n",sec);
            switch(sec){
                case 0:
                    MV->R[reg]=op2;
                    break;
                case 1:
                    op2=op2&0xFF;
                    MV->R[reg]=MV->R[reg]&mask4tobyte;
                    MV->R[reg]=MV->R[reg]|op2;
                    break;
                case 2:
                    op2=op2&0xFF;
                    //printf("op 2 luego de la mascara es %x   \n",op2);
                    MV->R[reg]=MV->R[reg]&mask3erbyte;
                    op2=op2<<8;
                    MV->R[reg]=MV->R[reg]|op2;
                    break;
                case 3:
                    op2=op2&0xFFFF;
                    //printf("op 2 luego de la mascara es %x   \n",op2);
                    MV->R[reg]=MV->R[reg]&mask2bytes;
                    MV->R[reg]=MV->R[reg] | op2;
                    break;
            }
            break;
        case 3:
            break;
    }
    //printf("el registro queda  %x",MV->R[reg]);
}

void dissaOp(char op, int v){
    char *registros[68]={"CS","DS","ES","SS","ks","IP","SP","BP","CC","AC","EAX","EBX","ECX","EDX","EEX","EFX","AL","BL","CL","DL","EL","FL","AH","BH","CH","DH","EH","FH","AX","BX","CX","DX","EX","FX"};
    int reg;
    char sec;
    int offset;
    char tamcel;
    switch(op){
        case 0:  //op de memoria
           // printf("v es %x \n",v);
            tamcel=(v>>22);
           // printf("tamcel es %d  \n",tamcel);
            reg=(v>>16)&0xF;
            offset=v&0xFFFF;
            //printf("reg es igual a %x",reg);
            //printf("el reg queda %s",registros[reg]);
            //printf("offset es igual a %x  \n", offset);
            if (tamcel==0)
            printf(" [%s + %X]", registros[reg], offset);
            else{
                switch(tamcel){
                    case 2:
                        printf(" w[%s + %X]", registros[reg], offset);
                        break;
                    case 3:
                        printf(" b[%s + %X]", registros[reg], offset);
                        break;
                }
            }
            break;
        case 1: //op inmediato
            printf(" %04X",v);
            break;
        case 2: //op de registro
            reg=v&0xF;
            sec=(v>>4)&0b11;
            switch(sec){
                case 0:
                    printf(" %s ",registros[reg]);
                    break;
                case 1:
                    printf(" %s ",registros[reg+6]);
                    break;
                case 2:
                    printf(" %s ",registros[reg+12]);
                    break;
                case 3:
                    printf(" %s ",registros[reg+18]);
                    break;
            }
            break;
    }
}

void Exec(TMV *MV, FILE *arch, int Dissasembler_True, char bufferVersion){
    char *mnemonicos[32]={"MOV", "ADD", "SUB", "SWAP", "MUL", "DIV", "CMP", "SHL", "SHR", "AND", "OR", "XOR", "RND","NaI","NaI","NaI","SYS","JMP","JZ","JP","JN","JNZ","JNP","JNN","LDL","LDH","NOT","PUSH","POP","CALL","RET","STOP"};
    char aux=0x0, instr=0x0, op1=0x0, op2=0x0;
    int v1=0x0, v2=0x0, i=0, mask1=0x00ff, auxilio;
    unsigned char posMemoriaKS, elementosKS;

    //printf("el ip en exec es %d \n" , MV->R[5]);

    //seteo el ip en el main
    /*if (Dissasembler_True && bufferVersion == 0x0002 && MV->R[4]>0){
        posMemoriaKS = MV->S[0][0];
        elementosKS = MV->M[posMemoriaKS];
        while (posMemoriaKS < MV->S[0][1]){
            printf("[%04X]", posMemoriaKS);
            printf("%c ", MV->M[posMemoriaKS]);
        }
    }*/
    //MV[5] =
    //printf("la tabla de seg ahi tiene %x   \n", MV->S[0][1]);
    while ((instr!=0x1f) && ((MV->R[5]&0xFFFF)<(MV->S[0][1]+MV->S[0][0]))){
       // printf("ip esta en %d  \n",MV->R[5]&0x00FF);
        aux=MV->M[MV->R[5]&0xFFFF];
       // printf("aux es igual a %x \n",(unsigned char)aux);
        if (Dissasembler_True){
            printf("[%04X]  ",(unsigned short)MV->R[5]&0x00FF);
            printf("%02X ",(unsigned char)aux);
        }
        ReadAux(aux, &instr, &op1, &op2);
        if ((instr < 0) || ((instr > 12) && (instr < 16)) || (instr > 31)){
            printf("Instruccion Inv�lida");
            exit(EXIT_FAILURE);
        }
        //printf("instr es %x , op1 es %x, op2 es %x \n",instr, op1, op2);
        //Readaux diseccione el byte auxy lo guarde en instr, op1 y op2
        ReadOp(op1, op2, arch, MV, &v1, &v2,Dissasembler_True);
        if (Dissasembler_True){
                printf(" %s ", mnemonicos[instr]);
                dissaOp(op1, v1);
                dissaOp(op2, v2);
                printf("\n");
        }
        //ReadOp leer del archivo los operando ()
        MV->R[5]++;
        Opera(instr, op1, op2, v1, v2, MV, bufferVersion);
        //printf("al principio del siguiente ciclo IP apunta a %x \n",(unsigned char)MV->M[MV->R[5]]);
    }
    //printf("SALI DEL WHILE DEL EXEC");
    //MV->R[1]=0x12345678;
    //auxilio=Getop(MV,2,0x31);
    //printf("getop es  %x",auxilio);
    //Setop(MV,0,0x010004,0x12);
}

void Disasembla(TMV *MV, FILE *arch, int Dissasembler_True, int offset){
    char *mnemonicos[32]={"MOV", "ADD", "SUB", "SWAP", "MUL", "DIV", "CMP", "SHL", "SHR", "AND", "OR", "XOR", "RND","NaI","NaI","NaI","SYS","JMP","JZ","JP","JN","JNZ","JNP","JNN","LDL","LDH","NOT","PUSH","POP","CALL","RET","STOP"};

    char aux=0x0, instr=0x0, op1=0x0, op2=0x0;
    int v1=0x0, v2=0x0, i=0, mask1=0x00ff, auxilio, limite=0;

    //MV->R[5] = MV->S[0][0];
    //printf("la tabla de seg ahi tiene %x   \n", MV->S[0][1]);
    limite = MV->S[1][0];
   // if (MV->R[4]>0){
      //  limite = limite + MV->S[1][1];
   // }
    printf("el limite es %d\n", limite);
    //printf("el ip antes de arrancar a disasemblar es %d", MV->R[5]&0xFFFF);
    while (/*(instr!=0x1f) && */((MV->R[5]&0xFFFF)<limite)){
        //printf("ip esta en %d  \n",MV->R[5]&0x00FF);
        aux=MV->M[MV->R[5]&0xFFFF];
        //printf("aux es igual a %x \n",(unsigned char)aux);
        if (Dissasembler_True){
            printf("[%04X]  ",(unsigned short)MV->R[5]&0xFFFF);
            printf("%02X ",(unsigned char)aux);
        }
        ReadAux(aux,&instr, &op1, &op2);
        if ((instr < 0)  /*|| ((instr > 12) && (instr < 16)) */|| (instr > 31)){
            printf("Instruccion Inv�lida");
            exit(EXIT_FAILURE);
        }
        //printf("instr es %x , op1 es %x, op2 es %x \n",instr, op1, op2);
        //Readaux diseccione el byte auxy lo guarde en instr, op1 y op2
        ReadOp(op1, op2, arch, MV, &v1, &v2,Dissasembler_True);
        if (Dissasembler_True){
                printf(" %s ", mnemonicos[instr]);
                dissaOp(op1, v1);
                dissaOp(op2, v2);
                printf("\n");
        }
        //ReadOp leer del archivo los operando ()
        MV->R[5]++;
        //printf("al principio del siguiente ciclo IP apunta a %x \n",(unsigned char)MV->M[MV->R[5]]);
    }
        MV->R[5] = MV->S[0][0] + offset; //HAY QUE REFACTORIZAR ESTO


    //MV->R[1]=0x12345678;
    //auxilio=Getop(MV,2,0x31);
    //printf("getop es  %x",auxilio);
    //Setop(MV,0,0x010004,0x12);
}


int main(int argc, char *argv[]) { //HAY QUE AGREGAR VARIABLES
    TMV MV;
    short int i=0, j=0, k=0, l=0, size, offset, stackSize = 0;
    FILE *arch;
    char bufferVersion, identif[6], BufferMem[SIZE_MEM];
    int cantidad_de_memoria, Dissasembler_True = 0, sizeint = 0, sizeTotalMemoria = 0, sizeCodeSegment = 0, sizeKonstantSegment = 0; // poner en 0
    //char *NombreDeArchivo = "ej.vmx";
    //Abro el archivo binario
    //PREGUNTAR SI QUIERE MODIFICAR LA MEMORIA, puede ser adentro o afuera del if
    if (argc <= 3) {//AHORA PUEDEN LLEGAR MAS ARGUMENTOS o que preguntas aca
        char *NombreDeArchivo = argv[1];
        printf("nombre de archivo es igual a %s \n",NombreDeArchivo);
        arch = fopen(NombreDeArchivo, "rb");   //sacar esta
        if (arch == NULL) {
            perror("Error al abrir el archivo.\n");
            exit(EXIT_FAILURE);
        }
        if (argc == 3 && strcmp(argv[2], "-d") == 0)
            Dissasembler_True = 1;
        //printf("el codigo dissasembler es %d \n", Dissasembler_True);
        fread(identif,sizeof(char),5,arch);
        identif[6]='\0';
        if (strcmp(identif,"VMX24")==0){ //PROGRAMA 1
            printf("El tipo de archivo es correcto \n");
            fread(&bufferVersion, sizeof(char), 1, arch);
            printf("la version es %d \n", bufferVersion);
            if (bufferVersion == 1){ //PROGRAMA VERSION 1
                //printf("entre a programa 1");
                //printf("El tipo de archivo y version son correctos \n");
                //printf("la version es %02X  \n",buffer);
                fread(&cantidad_de_memoria, sizeof(unsigned short int), 1, arch);   //Me lee los bytes al reves aca
                cantidad_de_memoria = reverseBytes(cantidad_de_memoria);
                printf("la cantidad de bytes de codigo son: %d \n", cantidad_de_memoria);
                fread(MV.M, sizeof(char), cantidad_de_memoria, arch);
                //Inicializacion de la tabla de segmentos
                MV.S[0][0]=0;
                MV.S[0][1]=cantidad_de_memoria;
                MV.S[1][0]=cantidad_de_memoria;
                MV.S[1][1]=800-MV.S[1][0];
                MV.R[1]=0x00010000;
                MV.R[0]=0; MV.R[2]=-1; MV.R[3]=-1; MV.R[4]=-1;
                offset = 0;
                //seteo el ip;
                MV.R[5] = MV.S[0][0];
                if (Dissasembler_True)
                    Disasembla(&MV, arch,Dissasembler_True, offset);
                Dissasembler_True=0;
                //seteo el ip;
                MV.R[5] = MV.S[0][0];
                //printf("TABLA DE SEGMENTOS \n");
              //  printf("[%d] [%d] \n",MV.S[0][0], MV.S[0][1]);
               // printf("[%d] [%d] \n",MV.S[1][0], MV.S[1][1]);

                Exec(&MV, arch, Dissasembler_True, bufferVersion);
               // for(i=0;i<=200;i++){
                  //  printf("[%d] ", i);
                  //  printf("%02X\n",(unsigned char) MV.M[i]);
               // }
               // printf("edx es %d ", MV.R[13]&0xFFFF );
            }
            if (bufferVersion == 0x0002){ //PROGRAMA VERSION 2
                //printf("entre a programa 2");
                MV.R[0] = 0;
                MV.R[1] = 0x00010000;
                MV.R[2] = 0x00020000;
                MV.R[3] = 0x00030000;
                MV.R[4] = 0x00040000;
                for (j=0; j<5; j++){ //leo los 5 tamaños RELATIVOS de los segmentos
                    fread(&size, sizeof(unsigned short int), 1, arch);
                    size = reverseBytes(size);
                    printf("TAMANIO DE R[%d] es %d \n", j, size);
                    if (size==0)
                        MV.R[j]= -1;
                    else{
                        if(j==0){
                            sizeCodeSegment = size;
                        }
                        if(j==4){
                            sizeKonstantSegment = size;
                        }
                        MV.S[j][1]=size;
                    }
                    sizeTotalMemoria=sizeTotalMemoria+size;


                    /*
                    size = reverseBytes(size);
                    printf("tamano de R[%d] es %d \n", j, size);
                    if (size == 0)
                        MV.R[j] = -1;
                    if (j==0){
                         sizeCodeSegment = size;
                         MV.S[0][0]=0;
                    }
                    MV.S[j][1]=size;
                    if (j!=4)
                    MV.S[j+1][0]=size+MV.S[j][0];
                    sizeTotalMemoria = sizeTotalMemoria + size;
                        //Dejo guardado los tamaños, luego reemplazo por direccion a la tabla de segmentos o -1
                        //MV.R[j] = (int)size << 16;

                        //MV.R[j] = MV.R[j] << 16;
                    */
                }
                //printf("el tamano total es %d \n", sizeTotalMemoria);
                if (sizeTotalMemoria > SIZE_MEM){
                    perror("Error - Espacio insuficiente.\n");
                }
                //Guardo el offset del entry point
                fread(&offset, sizeof(short int), 1, arch);
                offset = reverseBytes(offset);
                printf("el offset del entry point es %d \n", offset);
                //Cargo la memoria principal
                if (MV.R[4] > 0){//si Constants Segment (KS) existe va primero
                    //sizeTotalMemoria = sizeTotalMemoria - size; //le resto el tamaño de Constantes Segment porque va antes
                    //printf("size de KS es %d", size);
                    fread(&MV.M[size], sizeof(char), sizeCodeSegment, arch); //leo que hay adentro del CD hasta KS y lo meto en el buffer
                    fread(&MV.M[0], sizeof(char), size, arch); //leo KS y lo meto en la memoria
                    MV.S[4][0]=0;
                    MV.S[0][0]=MV.S[4][1];
                    MV.S[1][0]=MV.S[0][1]+MV.S[0][0];
                    MV.S[2][0]=MV.S[1][1]+MV.S[1][0];
                    MV.S[3][0]=MV.S[2][1]+MV.S[2][0];



                    //memcpy(MV.M + size, BufferMem, sizeCodeSegment); //concateno KS con el resto de segmentos
                    /*for (l = 0; l < sizeCodeSegment; l++) {
                        MV.M[size + l] = BufferMem[l];
                    }*/
                    //MV.S[0][1] = size;
                   // MV.S[1][0] = size;
                   // MV.R[4] = size; //HAY QUE REFACTORIZAR
                  //  MV.S[1][1] =  sizeCodeSegment; //HAY QUE REFACTORIZAR
                   // MV.S[2][0] = sizeCodeSegment; //HAY QUE REFACTORIZAR
                   // MV.R[1] = size + sizeCodeSegment; //HAY QUE REFACTORIZAR
                  //  MV.R[5] = MV.R[4];
                    //MV.R[5] |= (unsigned short int) offset;
                    MV.R[5]=MV.S[0][0];
                    printf("el ip es %d \n" , MV.R[5]);
                    k=1; //para acomodar el resto de los registros despues del KS
                }
                else{//si Constants Segment (KS) NO existe entonces pongo todo como viene
                    //MV.R[4] = -1;
                    fread(&MV.M[0], sizeof(char), sizeCodeSegment, arch);//leo los segmentos y los meto en la memoria
                    MV.S[4][0]=-1;
                    MV.S[0][0]=0;
                    MV.S[1][0]=MV.S[0][1]+MV.S[0][0];
                    MV.S[2][0]=MV.S[1][1]+MV.S[1][0];
                    MV.S[3][0]=MV.S[2][1]+MV.S[2][0];
                    MV.S[4][1]=0;
                    k=0; //para acomodar el resto de los registros desde 0
                    //MV.S[0][1] = sizeCodeSegment;
                   // MV.S[1][0] = sizeCodeSegment;
                   // MV.R[1] = 0;
                    //seteo el IP en el CS
                    MV.R[5] = MV.S[0][0];
                    //MV.R[5] |= (unsigned short int) offset;
                    k=1; //para acomodar el resto de los registros despues del KS
                }
                //seteo el IP en el CS
                //MV.R[5] = MV.R[0];
                //MV.R[5] |= (unsigned short int) offset;
                MV.R[6] = MV.S[3][0]+MV.S[3][1];
                printf("EL SP ES %d \n", MV.R[6]); 
                printf("tabla de segmentos \n");
                for (j=0; j<5; j++){
                    printf("en MV.S[%d][0] se guarda %d \n", j, MV.S[j][0]);
                    printf("en MV.S[%d][1] se guarda %d \n", j, MV.S[j][1]);
                }
               // for(i=0;i<=200;i++){
               //     printf("[%d] ", i);
               //     printf("%02X\n",(unsigned char) MV.M[i]);
               // }
                if (Dissasembler_True)
                    Disasembla(&MV, arch, Dissasembler_True, offset);
                Dissasembler_True=0;
                //printf("llegue aca");
                Exec(&MV, arch, Dissasembler_True, bufferVersion);
            }
        }
        if (strcmp(identif,"VMI24")==0){//IMAGEN
                fread(&cantidad_de_memoria,sizeof(unsigned short int),1,arch); //Lee los bytes al reves aca
                cantidad_de_memoria = reverseBytes(cantidad_de_memoria); // cant. mememoria principal
                printf("la cantidad de bytes de codigo son: %d \n", cantidad_de_memoria);
                //Lee registro (ocupan 64 bytes 16*4)
                for (j=0; j>15; j++){
                    fread(sizeint, sizeof(int), 1, arch);
                    MV.R[j] = (int)size << 16; //acomodo los registros
                }
                //Lee tabla de segmentos (ocupa 32 bytes 8*4)
                for (j=0; j>7; j++){
                    fread(sizeint, sizeof(int), 1, arch);//de a cuantos tamaño voy leyendo??
                    MV.S[j][j+1] = (int)size << 16; //acomodo los segmentos FALTA PONER DONDE, no es j y j+1
                }
                fread(MV.M, sizeof(char), cantidad_de_memoria, arch); //memoria principal
        }
        fclose(arch);
    }
    /*printf("sdsadsadsad");
    for(i=0;i<=200;i++){
        printf("%02X\n",(unsigned char) MV.M[i]);
    }

    printf("ac es %08x",MV.R[9]);
    printf("RESPUESTA \n");
    printf("en el ac hay %x \n",MV.R[9]);
    printf("el ds apunta a %d", MV.S[1][0]);
    printf("en ds + a hay %x %x %x %x %x %x",MV.M[76],MV.M[77],MV.M[78],MV.M[79],MV.M[80],MV.M[81]);
    printf("a partir de edx hay %x %x %x %x %x %x",MV.M[MV.R[13]],MV.M[MV.R[13]+1],MV.M[MV.R[13]+2],MV.M[MV.R[13]+3],MV.M[MV.R[13]+4],MV.M[MV.R[13]+5]);
    */
    return 0;
}

void SetSizes(char op1, char op2, char *size1, char *size2){
    switch(op1){
        case 0:
            *size1=3;
            break;
        case 1:
            *size1=2;
            break;
        case 2:
            *size1=1;
            break;
        case 3:
            *size1=0;
            break;
        default:
            printf("ERROR CODIGO DE OPERANDO 1"); }

    switch(op2){
        case 0:
            *size2=3;
            break;
        case 1:
            *size2=2;
            break;
        case 2:
            *size2=1;
            break;
         case 3:
            *size1=0; //esto era aproposito?
            break;
        default:
            printf("ERROR CODIGO DE OPERANDO 2"); }
}

//Funcion de acuerdo al tama�o que le llega devuelve el valor en la posicion indicada
void ReadSegunSize(char size, int *v, TMV *MV, int Dissasembler_True, int *cuantos) {
    //printf("el tamanio es: %d \n", size);
    *v=0;
    switch(size){
        case 0:
            *v=0;
            break;
        case 1:
            MV->R[5]++;
            *v=MV->M[MV->R[5]];
            if (Dissasembler_True){
            printf(" %02X ",*v);
            *cuantos=*cuantos+2;
            }
            break;
        case 2:
            MV->R[5]++;

            for(int i = 0; i < 2; ++i) {
            *v = (*v << 8) | (MV->M[MV->R[5]+i]&0xFF);
            }

          //  *v=(MV->M[MV->R[5]]<<8) | (MV->M[MV->R[5]+1]);
            MV->R[5]++;
            if (Dissasembler_True){
              printf(" %02X ",(*v)>>8);
              printf(" %02X ",*v&0xFF);
              *cuantos=*cuantos+4;
            }
            break;
        case 3:
            MV->R[5]++;
            *v=(MV->M[MV->R[5]]<<16)| (MV->M[MV->R[5]+1]<<8) | (MV->M[MV->R[5]+2]);
            if (*v&0xFF000000)
            *v=*v&0x00FFFFFF;
            //printf("en read segun size v es %x", *v);
            MV->R[5]++;
            MV->R[5]++;
            if (Dissasembler_True){
                //printf(" %X",(unsigned char) *v);
                printf(" %02X ",(*v)>>16);
                printf(" %02X ",((*v)>>8)&0xFF);
                printf(" %02X ",*v&0xFF);
                *cuantos=*cuantos+6;
            }
            break;
    }
    //printf("EN READ SEGUN SIZE V es %x  \n", *v);
}
void modificaCC(int aux, TMV *MV){
    if (aux < 0) {
        MV->R[8] = 0x80000000; // Pongo el bit N
        //MV->R[8] &= ~0x40000000; // Limpio el bit Z
    } else if (aux == 0) {
        //MV->R[8] &= ~0x80000000; // Limpio el bit N
        MV->R[8] = 0x40000000; // Pongo el bit Z
    } else {
        //MV->R[8] &= ~0x80000000; // Limpio el bit N
        //MV->R[8] &= ~0x40000000; // Limpio el bit Z
        MV->R[8] = 0x00000000;
    }
}
void MOV(char op1, int v1, char op2, int v2, TMV *MV){
   int aux, i;
   //scanf("%d", &i);
   //printf("aux  es: ");
   //imprimir_en_binario(aux);
   //printf("[10]  es: ");
   //imprimir_en_binario(MV->M[10]);
   aux = getOp(MV, op2, v2);
   //printf("aux en mov es: %x  \n", aux);
   setOp(MV, op1, v1, aux);
   //printf("CL es: %d  \n", MV->R[12]&0x000000FF);
  // printf(" ds + a es: %x %x %x %x\n", MV->M[76],MV->M[77], MV->M[78], MV->M[79]);
}
void ADD(char op1, int v1, char op2, int v2, TMV *MV){
    int aux1, aux2;
    aux1 = getOp(&(*MV), op1, v1);
    aux2 = getOp(&(*MV), op2, v2);
    //printf("aux1 es %d \n", aux1);
    //printf("aux2 es %d \n", aux2);
    aux1 = aux1 + aux2;
    modificaCC(aux1, &(*MV));
    setOp(&(*MV), op1, v1, aux1);
}
void SUB(char op1, int v1, char op2, int v2, TMV *MV){
    int aux1, aux2;
    aux1 = getOp(&(*MV), op1, v1);
    aux2 = getOp(&(*MV), op2, v2);
    //printf("aux1 es %d \n", aux1);
    //printf("aux2 es %d \n", aux2);
    aux1 = aux1 - aux2;
    modificaCC(aux1, &(*MV));
    //printf("aux 1 dsps de restar es %d \n", aux1);
    setOp(&(*MV), op1, v1, aux1);
}
void MUL(char op1, int v1, char op2, int v2, TMV *MV){
    int aux1, aux2;
    //printf("op 1 es %d \n", op1);
    //printf("a donde apunta eax tiene %x \n",MV->M[MV->R[10]+3]);
    //printf("a donde apunta ebx tiene %x \n",MV->M[MV->R[11]+3]);
    //printf("a donde apunta ecx tiene %x \n",MV->M[MV->R[12]+3]);
    //printf("v1 en mul es %x \n", v1);
    //printf("v2 en mul es %x \n", v2);
    aux1 = getOp(&(*MV), op1, v1);
    aux2 = getOp(&(*MV), op2, v2);
    //printf("aux1 en mul es %x \n", aux1);
    //printf("aux2 en mul es %x \n", aux2);
    aux1 = aux1 * aux2;
    modificaCC(aux1, &(*MV));
    //printf("aux1 dsps de multiplicar en mul es %x  \n", aux1);
    setOp(&(*MV), op1, v1, aux1);
}
void DIV(char op1, int v1, char op2, int v2, TMV *MV){
    int aux1, aux2;
    aux1 = getOp(&(*MV), op1, v1);
    aux2 = getOp(&(*MV), op2, v2);
    if (!aux2){
        printf("No se puede dividir por 0");
        exit(EXIT_FAILURE);
    }
    MV->R[9] = aux1 % aux2;//Resto en AC
    aux1 = aux1 / aux2;
    modificaCC(aux1, &(*MV));
    setOp(&(*MV), op1, v1, aux1);
}
void SWAP(char op1, int v1, char op2, int v2, TMV *MV){
    int aux1, aux2;
    aux1 = getOp(&(*MV), op1, v1);
    aux2 = getOp(&(*MV), op2, v2);
    //printf("aux1 es %d \n", aux1);
    //printf("aux2 es %d \n", aux2);
    setOp(&(*MV), op1, v1, aux2);
    setOp(&(*MV), op2, v2, aux1);
}
void CMP(char op1, int v1, char op2, int v2, TMV *MV){
    int aux1, aux2, res;
    //printf("ENTRE AL CMP \n");
   // printf(" v1 en cmp es %x, v2 en cmp es %x \n", v1, v2);
    aux1 = getOp(&(*MV), op1, v1);
    aux2 = getOp(&(*MV), op2, v2);
    res=aux1-aux2;

    //printf("aux1 en el cmp es %d \n", aux1);
   // printf("aux2 en el cmp es %d \n", aux2);
   // printf("RES ES %d  \n", res);
    /*if (aux2 > aux1)
        MV->R[8] |= 0x80000000;
    else
        MV->R[8] &= ~0x80000000;
    if (aux1 == aux2)
        MV->R[8] |= 0x40000000;
    else
        MV->R[8] &= ~0x40000000;*/
    if ((aux1 - aux2)<0) {
        MV->R[8] = 0x80000000;
    }
    else{
        if ((aux1 - aux2) == 0) {
            //printf("en el compare SON IGUALESSSSSSSSSSSSSSSSSSSSS");
            (MV)->R[8] = 0x40000000;
        }
        else
            MV->R[8] = 0x00000000;
    }
    //printf("CC es %x \n",MV->R[8]);
}
void AND(char op1, int v1, char op2, int v2, TMV *MV){
    int aux1, aux2;
    aux1 = getOp(&(*MV), op1, v1);
    aux2 = getOp(&(*MV), op2, v2);
    aux1 = aux1 & aux2;
    modificaCC(aux1, &(*MV));
    setOp(&(*MV), op1, v1, aux1);
}
void OR(char op1, int v1, char op2, int v2, TMV *MV){
    int aux1, aux2;
    aux1 = getOp(&(*MV), op1, v1);
    //printf("aux1 es: ");
    //imprimir_en_binario(aux1);
    aux2 = getOp(&(*MV), op2, v2);
    //printf("aux2 es: ");
    //imprimir_en_binario(aux2);
    aux1 = aux1 | aux2;
    modificaCC(aux1, &(*MV));
    //printf("resu es: ");
    //imprimir_en_binario(aux1);
    setOp(&(*MV), op1, v1, aux1);
}
void XOR(char op1, int v1, char op2, int v2, TMV *MV){
    int aux1, aux2;
    aux1 = getOp(&(*MV), op1, v1);
    aux2 = getOp(&(*MV), op2, v2);
   // printf("aux1 es %x, y aux2 es %x \n",aux1, aux2);
    aux1 = aux1 ^ aux2;
   // printf("AUX1 modificado es %x", aux1);
    modificaCC(aux1, &(*MV));
    setOp(&(*MV), op1, v1, aux1);
}
void SHL(char op1, int v1, char op2, int v2, TMV *MV){
    int aux1, aux2;
    aux1 = getOp(&(*MV), op1, v1);
    aux2 = getOp(&(*MV), op2, v2);  //ta mal falta considerar < 0
    aux1 = aux1 << aux2;
    modificaCC(aux1, &(*MV));
    setOp(&(*MV), op1, v1, aux1);
}
void SHR(char op1, int v1, char op2, int v2, TMV *MV){
    int aux1, aux2;
    aux1 = getOp(&(*MV), op1, v1);
    aux2 = getOp(&(*MV), op2, v2);  //ta mal
    aux1 = aux1 >> aux2;
    modificaCC(aux1, &(*MV));
    setOp(&(*MV), op1, v1, aux1);
}
void RND(char op1, int v1, char op2, int v2, TMV *MV){
    int aux1, aux2;
    aux1 = getOp(&(*MV), op1, v1);
    aux2 = getOp(&(*MV), op2, v2);
    aux1 = rand() % (aux2);
    setOp(&(*MV), op1, v1, aux1);
}

void setRead (char CH, TMV *MV, int posMemoria, int temp){
int i;
int aux=posMemoria;
for (int i = 0; i < CH; i++) {
        MV->M[aux] = (temp >> (8 * (CH - 1 - i))) & 0xFF;
        aux++;
    }


}

void readSYS(char AL, TMV *MV, int posMemoria){
    char CH;
    CH = (MV->R[12]>>8)&0xFF; //tamanio celdas
    int temp;
    switch(AL){
        case 8://lee hexadecimal
            scanf("%x", &temp);
            //printf("Read Hexa:  %x ", temp);
            break;
        case 4://lee octal
            scanf("%o", &temp);
            //printf("Read Octal:  %o ", temp);
            break;
        case 2://lee caracters
            scanf("%s", &temp);
            //printf("Read Char:  %c ", temp);
            break;
        case 1://lee decimal
            scanf("%d", &temp);
           // printf("Read en hexa queda:  %x ", temp);
            break;
    }
    setRead (CH, MV,posMemoria,temp);
   // for(int i=1175;i<=1200;i++){
     //   printf("[%d] ", i);
     //   printf("%02X\n",(unsigned char) MV->M[i]);
  //  }

    //strncpy(MV->M[posMemoria], temp, CH);
   // printf("en memoria hay %x %x %x %x  \n", MV->M[posMemoria+0], MV->M[posMemoria+1], MV->M[posMemoria+2], MV->M[posMemoria+3]);
}

int setRes (char CH, TMV *MV, int posMemoria){
    int aux=0;
    switch(CH){
        case 1://1 byte
        aux |= ((unsigned int)(unsigned char)MV->M[posMemoria]);
        break;
        case 2://2 byte
        aux |= ((unsigned int)(unsigned char)MV->M[posMemoria]) << 8;
        aux |= ((unsigned int)(unsigned char)MV->M[posMemoria+1]);
        break;
        case 4://4 byte
        aux |= ((unsigned int)(unsigned char)MV->M[posMemoria]) << 24;
        aux |= ((unsigned int)(unsigned char)MV->M[posMemoria+1]) << 16;
        aux |= ((unsigned int)(unsigned char)MV->M[posMemoria+2]) << 8;
        aux |= ((unsigned int)(unsigned char)MV->M[posMemoria+3]);
        break;
    }
    return aux;
}

void writeSYS(char AL, TMV *MV, int posMemoria){
    char CL, CH;
    CL = MV->R[12]&0xFF; //cant celdas
    CH = (MV->R[12]>>8)&0xFF; //tamanio celdas
    char  resultado[CH];
    int Res, i, j;
    char buffer[CH+1];
    //printf("CL es %d  \n", CL);
    //printf("CH es %d  \n", CH);
    //printf("AL es %d  \n", AL);
    switch(AL){
        case 8://escribe hexadecimal
            Res=setRes(CH, MV, posMemoria);
            printf("Hexa %:  %x ", Res);
            break;
        case 4://escribe octal
            Res=setRes(CH, MV, posMemoria);
            printf("Octal @:  %o ", Res);
            break;
        case 2://escribe caracters
            Res=setRes(CH, MV, posMemoria);
            for (i=0;i<CH+1;i++){
                j=CH-i;
                if (j==CH)
                    buffer[j]='\0';
                else
                buffer[j] = (char)((Res >> ((i-1)*8))& 0xFF);
            }
            printf("Char ':  %s ", buffer);
            break;
        case 1://escribe decimal
            Res=setRes(CH, MV, posMemoria);
            printf("Decimal #:  %d ", Res);
            break;
    }
}

void stringReadSYS(TMV *MV){
    int posMemoria = MV->S[(MV->R[13]&0xFFFF0000)>>16][0]+MV->R[13]&0xFFFF; //EDX
    int maxChars = MV->R[12] & 0xffff; //ECX ¿no tendria que ser un char maxChars y hacer que ECX se haga CX?
   // printf("ENTRO AL READSYS");
    if (maxChars != -1)//sin limites
        maxChars = 998;
    char buffer[maxChars + 1];
    fgets(buffer, maxChars + 1, stdin);
    for (int i = 0; i < strlen(buffer); i++){
        MV->M[posMemoria + i] = buffer[i];
    }
    MV->M[posMemoria + strlen(buffer)-1]=0;
   // MV->M[posMemoria + strlen(buffer)] = '\0';
    // for(int i = 0;i<10;i++){
    //    printf(" %x\n", MV->M[posMemoria+i]);
   // }
}
void stringWriteSYS(TMV *MV){
    //printf("ENTRO AL WRITE SYS");
    int posMemoria = MV->S[(MV->R[13]&0xFFFF0000)>>16][0]+MV->R[13]&0xFFFF; //EDX
    while (MV->M[posMemoria] != '\0' && MV->M[posMemoria] != '\n') {
        printf("%c", MV->M[posMemoria]);
        posMemoria++;
    }
    if (MV->M[posMemoria] == '\n')
        printf("\n");

    //printf("\n");
       // printf("LLEGO AL FINAL DEL AL WRITE SYS");
}
void clearScreen(){
    system("clear");
}
void breakpoint(TMV *MV, FILE *vmi_file){
    char choice;
    int estado;
    estado = fwrite(&MV, sizeof(TMV), 1, vmi_file);
    if (estado != 1) {
        perror("Error al escribir el archivo de imagen");
        return;
    }

    printf("Breakpoint: ingresar g para continuar, q para salir o enter para siguiente instrucción: ");
    choice = getchar();

    switch (choice) {
        case 'g':
            //llamar a la sig instruccion
            break;
        case 'q':
            // Abortar ejecución
            fclose(vmi_file);
            exit(EXIT_SUCCESS);
        case '\n':
            // Ejecutar siguiente instrucción y realizar nuevo breakpoint
            MV->R[5]++;
            breakpoint(MV, vmi_file);
            break;
        default:
            printf("Opción inválida\n");
            breakpoint(MV, vmi_file);
    }
}

void SYS(char op2, int v2, TMV *MV){
    int posMemoria =MV->S[MV->R[13]>>16][0]+(MV->R[13]&0xFFFF); //pos memoria (EDX)
    char CH = (MV->R[12]>>8)&0xFF; //tamanio celdas
    char CL = MV->R[12]&0xFF; //cant celdas
    char AL = MV->R[10]&0xFF; //config
    FILE *vmi_file;
    //printf("el modo de SYS es: %d", v2);
    switch (v2){
        case 1: //read
            while (CL > 0){
                printf("[%04x]: ", posMemoria);
                if (AL&0b1000)
                    readSYS(8, MV, posMemoria);
                if (AL&0b0100)
                    readSYS(4, MV, posMemoria);
                if (AL&0b0010)
                    readSYS(2, MV, posMemoria);
                if (AL&0b0001)
                    readSYS(1, MV, posMemoria);
                CL--;
                posMemoria+=CH;
                //printf("\n");
            }
            /*
            if (AL&0b0001){
                readSYS(1, MV);
            }
            if (AL&0b0010){
                readSYS(2, MV);
            }
            if (AL&0b0100){
                readSYS(4, MV);
            }
            if (AL&0b1000){
                readSYS(8, MV);
            }*/
            break;
        case 2: //write
            //AL = 0b1111;
            //printf("al es %x \n", AL);
            //imprimir_en_binario(AL);
            while (CL > 0){
                printf("[%04X]", posMemoria);
                if (AL&0b1000)
                    writeSYS(8, MV, posMemoria);
                if (AL&0b0100)
                    writeSYS(4, MV, posMemoria);
                if (AL&0b0010)
                    writeSYS(2, MV, posMemoria);
                if (AL&0b0001)
                    writeSYS(1, MV, posMemoria);
                CL--;
                posMemoria+=CH;
                printf("\n");
            }
            /*
            if (AL&0b0001)
                writeSYS(1, MV);
            if (AL&0b0010)
                writeSYS(2, MV);
            if (AL&0b0100)
                writeSYS(4, MV);
            if (AL&0b1000)
                writeSYS(8, MV);
            */
            break;
        case 3: //string read
            stringReadSYS(MV);
            break;
        case 4: //string write
            stringWriteSYS(MV);
            break;
        case 7: //clear screen
            clearScreen();
            break;
        case 15://breakpoint
            breakpoint(MV, vmi_file);
            break;
    }
   // printf("  \n SALGO DEL SYS");
}

void JMP(char op2, int v2, TMV *MV){
   // printf("ENTRO AL JMP");
    //printf("EAX o DS es %x \n", MV->R[10]);
    char aux;
    int i;
    MV->R[5] = MV->S[0][0]+getOp(&(*MV), op2, v2);
}
// (*MV)->[8] & 0b10000000 es el bit N
// (*MV)->[8] & 0b01000000 es el bit Z
void JZ(char op2, int v2, TMV *MV){
    //printf("ENTRE AL JZ, cc es %x \n", MV->R[8]);
    //if (MV->R[8] & 0b01000000){ //¿no deberia ser 0b01000000000000000000000000000000?
    if (MV->R[8] & 0x40000000){
        //printf("SALTO EN EL JZ");
        MV->R[5] = MV->S[0][0]+getOp(&(*MV), op2, v2);
    }
}
void JP(char op2, int v2, TMV *MV){
    char aux;
    //if (MV->R[8]==0x0){
    //if (!((MV)->R[8] & 0b01000000) && (!(MV)->R[8] & 0b10000000))
    if (MV->R[8]==0x0){
        MV->R[5] = MV->S[0][0]+getOp(&(*MV), op2, v2);
        //printf("EL ip queda dsps del jmp en %x",MV->R[5]);
        //scanf("%c",&aux);
    }
}
void JN(char op2, int v2, TMV *MV){
    //if (MV->R[8] & 0b10000000){ //¿no deberia ser 0b10000000000000000000000000000000?
    if (MV->R[8] & 0x80000000){
        MV->R[5] = MV->S[0][0]+getOp(&(*MV), op2, v2);
    }
}
void JNZ(char op2, int v2, TMV *MV){
    //if (!(MV->R[8] & 0b01000000)){
    if (!(MV->R[8] & 0x40000000)){
        MV->R[5] = MV->S[0][0]+getOp(&(*MV), op2, v2);
    }
}
void JNP(char op2, int v2, TMV *MV){
    //if (MV->R[8] & 0b10000000 || MV->R[8] & 0b01000000 ){
    if (MV->R[8]!=0x0){ //y si el resto del numero tiene basura?
        MV->R[5] =MV->S[0][0]+ getOp(&(*MV), op2, v2);
    }
}
void JNN(char op2, int v2, TMV *MV){
   // for(int i=140;i<=160;i++){
     //   printf("[%d] ", i);
     //   printf("%02X\n",(unsigned char) MV->M[i]);
   // }
    //if (!(MV->R[8] & 0b10000000)){
    if (!(MV->R[8] & 0x80000000)){
        MV->R[5] = MV->S[0][0]+getOp(&(*MV), op2, v2);
    }
}
void LDH(char op2, int v2, TMV *MV){
    int aux=getOp(&(*MV), op2, v2);
   // printf("aux es igual a %x \n",aux);
    MV->R[9]=(MV->R[9] & 0x0000FFFF) | (aux << 16);
   // printf("ac es igual a %08x \n",MV->R[9]);
    //(MV)->R[9] = (getOp(&(*MV), op2, v2)) << 6;
}
void LDL(char op2, int v2, TMV *MV){
    int aux=getOp(&(*MV), op2, v2);
   // printf("aux es igual a %x \n",aux);
    MV->R[9] = (MV->R[9] & 0xFFFF0000) | (aux & 0x0000FFFF);
    //(MV)->R[9] = (getOp(&(*MV), op2, v2)) & 0b00000011;
}
void NOT(char op2, int v2, TMV *MV){
    int aux1, aux2;
    aux1 = (getOp(&(*MV), op2, v2));
   // printf("aux1 antes de notearlo es %d \n", aux1);
    aux1=~aux1;
   // printf("aux1 noteado es %d \n", aux1);
    setOp(&(*MV), op2, v2, aux1);
    modificaCC(aux1, (&(*MV)));
}
void PUSH(char op2, int v2, TMV *MV){
    int aux;
    MV->R[6] = MV->R[6] - 4;
    //printf("SS es %x  \n", (MV->R[3]>>16));
    if (MV->R[6] < MV->S[3][0]){
     //   printf("SP es %d, y deberia ser mayor que %d \n",MV->R[6],MV->S[(MV->R[3])>>16][0]  );
        printf("Stack overflow.\n");
       exit(1);
    }
    aux = getOp(&(*MV), op2, v2);
   // printf("AUX A PUSHEAR ES %x \n", aux);
    
    //aux = aux | 0xFFFF0000;
    //printf("AUX A PUSHEAR ES %d \n", aux);
    //Almaceno en la pila desde los bytes menos significativos
    MV->M[MV->R[6]] = (aux >> 24) & 0xFF; // Byte más significativo
    MV->M[MV->R[6]+1] = (aux >> 16) & 0xFF;
    MV->M[MV->R[6]+2] = (aux >> 8) & 0xFF;
    MV->M[MV->R[6]+3] = aux & 0xFF;  
    for(int i=0;i<10;i++){
       // printf("mem[%x]",MV->R[6]+i);
       // printf("%x \n",MV->M[MV->R[6]+i]);
    }

    // *(MV->M + MV->R[6]) = aux;
}
int getSize(char op2) {
    switch (op2) {
        case 0x00:
            return 4; // 4 bytes si es long (00)
        case 0x10:
            return 2; // 2 bytes si es word (10)
        case 0x11:
            return 1; // 1 byte si es byte (11)
        default:
            return 0; // Tamaño no válido
    }
}
void POP(char op2, int v2, TMV*MV){
    int aux=0;
    aux |= (MV->M[MV->R[6]] << 24);
    aux |= (MV->M[MV->R[6]+1] << 16);
    aux |= (MV->M[MV->R[6]+2] << 8);
    aux |= MV->M[MV->R[6]+3];
    setOp(MV, op2, 0, aux);
    if (MV->R[6] >= MV->R[3] + MV->S[3][1]) //REPENSAR ESTE IF
        perror("Stack underflow.\n");
    //if (op2 == 0x00)
      //  setOp(MV, op2, 0, aux);
    //else
      //  setOp(MV, op2, 0, (aux << (32 - (8 * getSize(op2)))) >> (32 - (8 * getSize(op2))));
    MV->R[6] += 4;
}
void CALL(char op2, int v2, TMV*MV){
    int aux;
    aux=getOp(&(*MV), op2, v2);
    PUSH(2,5,MV);
    JMP(1,aux,MV);
    //aux = (MV->R[5] & 0xFFFF0000) | (MV->R[0] & 0x0000FFFF);
   // PUSH(op2, aux, MV);
   // MV->R[5] = (MV->R[5] & 0xFFFF0000) | (v2 & 0x0000FFFF);
}
void RET(TMV *MV){ //es como un POP IP, no llame a POP para que quede desacoplado aunque podria usarlo.
   int aux;
   aux = *(MV->M + MV->R[6]);
    if (MV->R[6] >= MV->R[3] + MV->S[3][1])
        perror("Stack underflow.\n");
    MV->R[5] = (MV->R[5] & 0x0000FFFF) | (aux & 0xFFFF0000);
    MV->R[0] = aux & 0x0000FFFF;
    MV->R[6] += 4;
}
void STOP(TMV *MV){

}